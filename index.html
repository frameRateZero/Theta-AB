<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a0f">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<title>θ WAVE v2.0 — Attentional Blink Lab</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg:#08080f;--surface:#0f0f1a;--border:#1e1e30;
    --theta:#00e5ff;--theta-dim:rgba(0,229,255,0.12);--theta-glow:rgba(0,229,255,0.4);
    --danger:#ff3c5a;--danger-dim:rgba(255,60,90,0.2);
    --text:#e8e8f0;--muted:#5a5a7a;--success:#39ff8a;--warning:#ffcc00;--amber:#ff9d00;
    --font-mono:'Space Mono',monospace;--font-display:'Syne',sans-serif;
  }
  *{box-sizing:border-box;margin:0;padding:0;}
  body{background:var(--bg);color:var(--text);font-family:var(--font-mono);min-height:100dvh;overflow:hidden;}
  body::before{content:'';position:fixed;inset:0;
    background-image:linear-gradient(rgba(0,229,255,0.025) 1px,transparent 1px),
    linear-gradient(90deg,rgba(0,229,255,0.025) 1px,transparent 1px);
    background-size:40px 40px;pointer-events:none;z-index:0;}
  body::after{content:'';position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
    width:600px;height:600px;
    background:radial-gradient(ellipse,rgba(0,229,255,0.04) 0%,transparent 70%);
    pointer-events:none;z-index:0;}

  .screen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;
    justify-content:center;z-index:10;transition:opacity 0.35s ease;padding:24px;}
  .screen.hidden{opacity:0;pointer-events:none;}

  /* HOME */
  #home-screen{gap:18px;overflow-y:auto;justify-content:flex-start;
    padding:44px 24px 64px;position:absolute;}
  .logo-theta{font-family:var(--font-display);font-size:clamp(52px,15vw,96px);font-weight:800;
    color:var(--theta);text-shadow:0 0 60px var(--theta-glow);line-height:1;letter-spacing:-2px;}
  .logo-sub{font-family:var(--font-display);font-size:clamp(10px,2.5vw,13px);
    letter-spacing:4px;text-transform:uppercase;color:var(--muted);}
  .badge-row{display:flex;gap:7px;flex-wrap:wrap;justify-content:center;}
  .badge{background:var(--theta-dim);border:1px solid rgba(0,229,255,0.2);border-radius:20px;
    padding:3px 10px;font-size:9px;letter-spacing:2px;text-transform:uppercase;color:var(--theta);}
  .info-card{background:var(--surface);border:1px solid var(--border);border-radius:12px;
    padding:16px 18px;max-width:420px;width:100%;}
  .info-card h3{font-family:var(--font-display);font-size:10px;letter-spacing:4px;
    text-transform:uppercase;color:var(--theta);margin-bottom:10px;}
  .info-card p{font-size:12px;line-height:1.75;color:var(--muted);}
  .changelog{max-width:420px;width:100%;background:rgba(255,157,0,0.07);
    border:1px solid rgba(255,157,0,0.2);border-radius:10px;padding:10px 14px;
    font-size:10px;line-height:1.7;color:var(--muted);}
  .changelog strong{color:var(--warning);}

  .btn-primary{background:var(--theta);color:var(--bg);border:none;border-radius:8px;
    padding:13px 28px;font-family:var(--font-display);font-size:13px;font-weight:700;
    letter-spacing:2px;text-transform:uppercase;cursor:pointer;transition:all 0.2s;
    touch-action:manipulation;user-select:none;}
  .btn-primary:hover{transform:translateY(-2px);box-shadow:0 0 48px var(--theta-glow);}
  .btn-primary:active{transform:translateY(0);}
  .btn-secondary{background:transparent;color:var(--muted);border:1px solid var(--border);
    border-radius:8px;padding:11px 22px;font-family:var(--font-display);font-size:11px;
    font-weight:700;letter-spacing:2px;text-transform:uppercase;cursor:pointer;transition:all 0.2s;
    touch-action:manipulation;user-select:none;}
  .btn-secondary:hover{border-color:var(--theta);color:var(--theta);}
  .btn-row{display:flex;gap:9px;flex-wrap:wrap;justify-content:center;}

  /* CALIBRATION */
  #calibration-screen{gap:22px;}
  .screen-title{font-family:var(--font-display);font-size:clamp(20px,5vw,26px);
    font-weight:800;letter-spacing:-0.5px;}
  .screen-sub{font-size:10px;letter-spacing:3px;text-transform:uppercase;color:var(--muted);}
  .calib-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;width:100%;max-width:360px;}
  .calib-item{background:var(--surface);border:1px solid var(--border);border-radius:10px;padding:14px;}
  .calib-label{font-size:9px;letter-spacing:3px;text-transform:uppercase;color:var(--muted);margin-bottom:6px;}
  .calib-val{font-family:var(--font-display);font-size:20px;font-weight:700;color:var(--theta);}
  .calib-bar{height:3px;background:var(--border);border-radius:2px;overflow:hidden;margin-top:6px;}
  .calib-fill{height:100%;background:var(--theta);border-radius:2px;width:0%;transition:width 0.4s;}

  /* TASK */
  #task-screen{background:var(--bg);padding:0;}
  #task-canvas{position:absolute;inset:0;width:100%;height:100%;cursor:none;}
  .task-hud{position:fixed;top:0;left:0;right:0;display:flex;justify-content:space-between;
    align-items:flex-start;padding:10px 16px;z-index:20;pointer-events:none;
    background:linear-gradient(rgba(8,8,15,0.7),transparent);}
  .hud-item{display:flex;flex-direction:column;gap:2px;}
  .hud-label{font-size:7px;letter-spacing:3px;text-transform:uppercase;color:var(--muted);}
  .hud-val{font-family:var(--font-display);font-size:17px;font-weight:700;color:var(--theta);}
  .hud-conf-bar{width:72px;height:3px;background:var(--border);border-radius:2px;margin-top:3px;}
  .hud-conf-fill{height:100%;border-radius:2px;
    background:linear-gradient(90deg,var(--danger),var(--warning),var(--success));width:0%;}

  /* FULLSCREEN TAP OVERLAY — sits above canvas, catches all touches */
  #tap-overlay{position:fixed;inset:0;z-index:25;display:none;
    -webkit-tap-highlight-color:transparent;touch-action:manipulation;
    cursor:none;user-select:none;}
  /* Subtle bottom-of-screen tap indicator */
  #tap-indicator{position:fixed;bottom:0;left:0;right:0;height:5px;
    background:rgba(0,229,255,0.0);z-index:26;pointer-events:none;
    transition:background 0.08s;}
  #tap-indicator.tapped{background:rgba(0,229,255,0.35);}

  /* RESULTS */
  #results-screen{gap:18px;overflow-y:auto;padding:44px 24px 64px;justify-content:flex-start;}
  .result-card{background:var(--surface);border:1px solid var(--border);border-radius:14px;
    padding:20px 22px;width:100%;max-width:480px;}
  .result-hz{font-family:var(--font-display);font-size:clamp(42px,12vw,72px);font-weight:800;
    color:var(--theta);line-height:1;text-shadow:0 0 40px var(--theta-glow);}
  .result-unit{font-size:11px;letter-spacing:3px;text-transform:uppercase;color:var(--muted);margin-top:4px;}
  .result-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:16px;}
  .result-item{background:rgba(0,229,255,0.04);border:1px solid var(--border);
    border-radius:8px;padding:10px 12px;}
  .result-label{font-size:8px;letter-spacing:3px;text-transform:uppercase;color:var(--muted);margin-bottom:4px;}
  .result-val{font-family:var(--font-display);font-size:18px;font-weight:700;color:var(--text);}
  .conf-bar-outer{height:8px;background:var(--border);border-radius:4px;overflow:hidden;margin-top:8px;}
  .conf-bar-inner{height:100%;border-radius:4px;
    background:linear-gradient(90deg,var(--danger),var(--warning),var(--success));
    transition:width 0.6s ease;}
  .chart-wrap{width:100%;max-width:480px;background:var(--surface);
    border:1px solid var(--border);border-radius:14px;padding:16px;}
  .chart-label{font-size:9px;letter-spacing:3px;text-transform:uppercase;
    color:var(--muted);margin-bottom:10px;}
  canvas{display:block;}
  .interp-card{background:rgba(0,229,255,0.04);border:1px solid rgba(0,229,255,0.15);
    border-radius:12px;padding:16px 18px;max-width:480px;width:100%;
    font-size:12px;line-height:1.75;color:var(--muted);}

  /* HISTORY */
  #history-screen{gap:18px;overflow-y:auto;padding:44px 24px 64px;justify-content:flex-start;}
  .history-entry{background:var(--surface);border:1px solid var(--border);border-radius:10px;
    padding:14px 16px;display:flex;justify-content:space-between;align-items:flex-start;
    max-width:480px;width:100%;gap:12px;}
  .history-hz{font-family:var(--font-display);font-size:22px;font-weight:700;color:var(--theta);}
  .history-conf{font-size:10px;color:var(--muted);margin-top:4px;line-height:1.5;}
  .history-meta{font-size:9px;color:var(--muted);text-align:right;white-space:nowrap;}

  /* SETTINGS PANEL */
  .settings-panel{width:100%;max-width:380px;background:var(--surface);
    border:1px solid var(--border);border-radius:16px;padding:18px 20px;
    display:flex;flex-direction:column;gap:10px;}
  .settings-title{font-family:var(--font-display);font-size:11px;font-weight:700;
    letter-spacing:3px;text-transform:uppercase;color:var(--muted);margin-bottom:2px;}
  .setting-row{display:flex;flex-direction:column;gap:6px;}
  .setting-label{display:flex;justify-content:space-between;align-items:center;}
  .setting-name{font-size:11px;letter-spacing:1px;text-transform:uppercase;color:var(--muted);}
  .setting-val{font-family:var(--font-display);font-size:13px;font-weight:700;color:var(--theta);}
  .setting-slider{-webkit-appearance:none;appearance:none;width:100%;height:3px;
    border-radius:2px;background:var(--border);outline:none;cursor:pointer;}
  .setting-slider::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;
    border-radius:50%;background:var(--theta);cursor:pointer;border:2px solid var(--bg);}
  .setting-slider::-moz-range-thumb{width:18px;height:18px;border-radius:50%;
    background:var(--theta);cursor:pointer;border:2px solid var(--bg);}
  .setting-toggle{display:flex;gap:0;border-radius:8px;overflow:hidden;border:1px solid var(--border);}
  .setting-toggle button{flex:1;padding:7px 4px;font-family:var(--font-mono);font-size:10px;
    letter-spacing:1px;text-transform:uppercase;background:transparent;
    border:none;color:var(--muted);cursor:pointer;transition:all 0.15s;}
  .setting-toggle button.active{background:var(--theta-dim);color:var(--theta);}
  .settings-divider{height:1px;background:var(--border);margin:2px 0;}

  /* TOAST */
  #toast{position:fixed;bottom:32px;left:50%;transform:translateX(-50%);
    background:var(--surface);border:1px solid var(--border);border-radius:8px;
    padding:10px 20px;font-size:12px;color:var(--text);z-index:100;
    transition:opacity 0.3s;pointer-events:none;}
  #toast.hidden{opacity:0;}

  /* INSTRUCTIONS OVERLAY */
  .overlay{position:fixed;inset:0;background:rgba(8,8,15,0.94);z-index:50;
    display:flex;align-items:center;justify-content:center;padding:24px;}
  .overlay.hidden{display:none;}
  .overlay-card{background:var(--surface);border:1px solid var(--border);border-radius:16px;
    padding:28px;max-width:400px;width:100%;max-height:80dvh;overflow-y:auto;}
  .overlay-card h2{font-family:var(--font-display);font-size:18px;font-weight:800;
    color:var(--theta);margin-bottom:16px;}
  .overlay-card p{font-size:12px;line-height:1.8;color:var(--muted);margin-bottom:12px;}
  .overlay-card strong{color:var(--text);}
</style>
</head>
<body>

<!-- ═══════════════════════════════════════════ HOME SCREEN -->
<div id="home-screen" class="screen">
  <div>
    <div class="logo-theta">θ</div>
    <div class="logo-sub">Neural Theta Frequency Estimator · v2.0</div>
  </div>
  <div class="badge-row">
    <span class="badge">Twitch Paradigm</span>
    <span class="badge">RT-Weighted QUEST</span>
    <span class="badge">Adaptive Contrast</span>
    <span class="badge">Line Mask</span>
    <span class="badge">EIG Sampling</span>
    <span class="badge">CSV Export</span>
  </div>
  <div class="info-card">
    <h3>What this measures</h3>
    <p>A digit flashes among letters — tap <strong style="color:var(--theta)">T1</strong> when you see it. Shortly after, another digit appears — tap <strong style="color:var(--success)">T2</strong> when you see it. Your reaction times and the pattern of misses reveal the theta-frequency attentional blink cycle. No prompts, no catch trials — just stream, tap, repeat.</p>
  </div>
  <div class="changelog">
    <strong>v2.0 changelog:</strong> Twitch paradigm — tap T1 then T2 &middot; T1 RT weights QUEST updates &middot; Adaptive contrast per SOA bin &middot; Line fragment mask after digits &middot; No catch trials / ITI / response prompts
  </div>

  <div class="settings-panel">
    <div class="settings-title">&#9881; Session Settings</div>

    <div class="setting-row">
      <div class="setting-label">
        <span class="setting-name">Stream Speed</span>
        <span class="setting-val" id="lbl-speed">—</span>
      </div>
      <input type="range" class="setting-slider" id="sl-speed" min="6" max="16" step="1" value="8" oninput="updateSettings()">
    </div>

    <div class="setting-row">
      <div class="setting-label">
        <span class="setting-name">T1 Font Size</span>
        <span class="setting-val" id="lbl-t1font">—</span>
      </div>
      <input type="range" class="setting-slider" id="sl-t1font" min="48" max="108" step="8" value="96" oninput="updateSettings()">
    </div>

    <div class="settings-divider"></div>

    <div class="setting-row">
      <div class="setting-label">
        <span class="setting-name">SOA Max</span>
        <span class="setting-val" id="lbl-soamax">—</span>
      </div>
      <input type="range" class="setting-slider" id="sl-soamax" min="400" max="1200" step="50" value="800" oninput="updateSettings()">
    </div>

    <div class="setting-row">
      <div class="setting-label">
        <span class="setting-name">Trials</span>
        <span class="setting-val" id="lbl-trials">—</span>
      </div>
      <input type="range" class="setting-slider" id="sl-trials" min="40" max="300" step="10" value="120" oninput="updateSettings()">
    </div>

    <div class="settings-divider"></div>

    <div class="setting-row">
      <div class="setting-label" style="justify-content:flex-start;gap:10px;">
        <input type="checkbox" id="chk-mask" onchange="updateSettings()" style="accent-color:var(--theta);width:16px;height:16px;cursor:pointer;">
        <span class="setting-name">Line Mask</span>
        <span class="setting-val" style="font-size:9px;color:var(--muted);margin-left:auto;">may cue T2</span>
      </div>
    </div>

  </div>

  <div style="display:flex;flex-direction:column;gap:10px;align-items:center;width:100%;max-width:240px;">
    <button class="btn-primary" onclick="showScreen('calibration-screen')">Begin Session</button>
    <button class="btn-secondary" onclick="showHistory()">Past Results</button>
    <button class="btn-secondary" onclick="document.getElementById('instructions-overlay').classList.remove('hidden')">Instructions</button>
  </div>
</div>

<!-- ═══════════════════════════════════════════ INSTRUCTIONS OVERLAY -->
<div id="instructions-overlay" class="overlay hidden">
  <div class="overlay-card">
    <h2>How to play</h2>
    <p>A stream of letters flows across the screen. <strong>Digits</strong> occasionally appear among them.</p>
    <p>When you see the <strong style="color:var(--theta)">first digit (T1)</strong> — tap the <strong style="color:var(--theta)">T1 button</strong> (left) as fast as you can.</p>
    <p>Shortly after, a <strong style="color:var(--success)">second digit (T2)</strong> may appear — tap the <strong style="color:var(--success)">T2 button</strong> (right) if you see it. If you don't see it, don't tap — silence means miss.</p>
    <p>Both digits are <strong>white</strong> against gray letters. T2 may be faint — it adapts to your detection level. T1 and T2 are from different number ranges to help tell them apart.</p>
    <p>Your <strong>reaction time</strong> to T1 tells the system how strongly it captured your attention — faster T1 RT means a deeper blink is expected.</p>
    <p>Keep your thumbs resting on the buttons throughout. Eyes on the centre.</p>
    <button class="btn-primary" style="width:100%;margin-top:8px;" onclick="document.getElementById('instructions-overlay').classList.add('hidden');showScreen('calibration-screen')">Got it — continue</button>
  </div>
</div>

<!-- ═══════════════════════════════════════════ CALIBRATION SCREEN -->
<div id="calibration-screen" class="screen hidden">
  <div class="screen-title">Display Check</div>
  <div class="screen-sub">Measuring refresh rate</div>
  <div class="calib-grid">
    <div class="calib-item">
      <div class="calib-label">Refresh Rate</div>
      <div class="calib-val" id="calib-hz">…</div>
      <div class="calib-bar"><div class="calib-fill" id="calib-hz-bar"></div></div>
    </div>
    <div class="calib-item">
      <div class="calib-label">Timing Jitter</div>
      <div class="calib-val" id="calib-jitter">…</div>
      <div class="calib-bar"><div class="calib-fill" id="calib-jitter-bar"></div></div>
    </div>
    <div class="calib-item">
      <div class="calib-label">Frame Duration</div>
      <div class="calib-val" id="calib-isi">…</div>
    </div>
    <div class="calib-item">
      <div class="calib-label">Status</div>
      <div class="calib-val" id="calib-status" style="font-size:14px;">…</div>
    </div>
  </div>
  <div id="calib-btns" style="opacity:0;transition:opacity 0.5s;" class="btn-row">
    <button class="btn-primary" onclick="startSession()">Start Task</button>
    <button class="btn-secondary" onclick="showScreen('home-screen')">Back</button>
  </div>
</div>

<!-- ═══════════════════════════════════════════ TASK SCREEN -->
<div id="task-screen" class="screen hidden">
  <canvas id="task-canvas"></canvas>
  <div class="task-hud">
    <div class="hud-item">
      <div class="hud-label">Trial</div>
      <div class="hud-val" id="hud-trial">0</div>
    </div>
    <div class="hud-item" style="align-items:center;">
      <div class="hud-label">Confidence</div>
      <div class="hud-conf-bar"><div class="hud-conf-fill" id="hud-conf"></div></div>
    </div>
    <div class="hud-item" style="align-items:center;">
      <div class="hud-label">T1 RT</div>
      <div class="hud-val" id="hud-t1rt">—</div>
    </div>
    <div class="hud-item" style="align-items:flex-end;">
      <div class="hud-label">Contrast</div>
      <div class="hud-val" id="hud-contrast">—</div>
    </div>
  </div>
  <!-- Fullscreen tap overlay — above canvas, below abort button -->
  <div id="tap-overlay"></div>
  <div id="tap-indicator"></div>
  <button class="btn-secondary" style="position:fixed;top:12px;right:12px;z-index:30;
    padding:6px 12px;font-size:9px;opacity:0.4;" onclick="abortSession()">✕</button>
</div>

<!-- ═══════════════════════════════════════════ RESULTS SCREEN -->
<div id="results-screen" class="screen hidden">
  <div class="result-card" style="max-width:480px;width:100%;">
    <div style="display:flex;justify-content:space-between;align-items:flex-start;">
      <div>
        <div class="result-hz" id="res-hz">—</div>
        <div class="result-unit" id="res-unit">Hz</div>
      </div>
      <div style="text-align:right;">
        <div style="font-size:9px;letter-spacing:3px;text-transform:uppercase;color:var(--muted);">Confidence</div>
        <div id="conf-label" style="font-family:var(--font-display);font-size:13px;font-weight:700;">—</div>
        <div class="conf-bar-outer" style="margin-top:6px;">
          <div class="conf-bar-inner" id="conf-bar" style="width:0%"></div>
        </div>
      </div>
    </div>
    <div class="result-grid">
      <div class="result-item">
        <div class="result-label">Trough</div>
        <div class="result-val" id="res-period">—</div>
      </div>
      <div class="result-item">
        <div class="result-label">Blink Depth</div>
        <div class="result-val" id="res-depth">—</div>
      </div>
      <div class="result-item">
        <div class="result-label">Baseline</div>
        <div class="result-val" id="res-baseline">—</div>
      </div>
      <div class="result-item">
        <div class="result-label">Amplitude</div>
        <div class="result-val" id="res-tau">—</div>
      </div>
    </div>
  </div>

  <div class="chart-wrap">
    <div class="chart-label">Detection Rate &amp; Model Fit — SOA</div>
    <canvas id="soa-chart"></canvas>
  </div>
  <div class="chart-wrap">
    <div class="chart-label">Adaptive T2 Contrast — by SOA Bin</div>
    <canvas id="contrast-chart"></canvas>
  </div>
  <div class="chart-wrap">
    <div class="chart-label">Posterior Probability — Theta Frequency</div>
    <canvas id="freq-chart"></canvas>
  </div>

  <div class="interp-card" id="blink-interp">—</div>

  <div class="btn-row">
    <button class="btn-primary" onclick="downloadCSV()">Export CSV</button>
    <button class="btn-secondary" onclick="startSession()">Run Again</button>
    <button class="btn-secondary" onclick="showScreen('home-screen')">Home</button>
  </div>
</div>

<!-- ═══════════════════════════════════════════ HISTORY SCREEN -->
<div id="history-screen" class="screen hidden">
  <div class="screen-title">Past Sessions</div>
  <div id="history-list" style="width:100%;max-width:480px;display:flex;flex-direction:column;gap:10px;"></div>
  <div class="btn-row">
    <button class="btn-secondary" onclick="clearHistory()">Clear</button>
    <button class="btn-secondary" onclick="showScreen('home-screen')">Back</button>
  </div>
</div>

<div id="toast" class="hidden">—</div>

<script>
// ════════════════════════════════════════════════════════════════════
//  θ WAVE v2.0 — Twitch Paradigm
//  T1 tap → RT captured → weights QUEST
//  T2 tap → detection at adaptive contrast per SOA bin
//  Line fragment mask after each digit slot
//  No catch trials, no ITI, no response prompts
// ════════════════════════════════════════════════════════════════════

// ── Screens ───────────────────────────────────────────────────────────
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s =>
    s.classList.toggle('hidden', s.id !== id));
  if (id === 'calibration-screen') {
    document.getElementById('calib-btns').style.opacity = '0';
    setTimeout(calibrate, 150);
  }
  if (id === 'home-screen') {
    updateSettings();
  }
}
function showHistory() { renderHistory(); showScreen('history-screen'); }
function toast(msg, ms=2200) {
  const el = document.getElementById('toast');
  el.textContent = msg; el.classList.remove('hidden');
  clearTimeout(toast._t);
  toast._t = setTimeout(() => el.classList.add('hidden'), ms);
}

// ── Calibration ───────────────────────────────────────────────────────
let measuredFPS = 120;
function calibrate() {
  const timings = []; let last=null, frames=0;
  function measure(ts) {
    if (last !== null) timings.push(ts - last);
    last = ts; frames++;
    if (frames < 120) { requestAnimationFrame(measure); return; }
    const avg = timings.reduce((a,b)=>a+b,0) / timings.length;
    const vr  = timings.map(t=>(t-avg)**2).reduce((a,b)=>a+b,0) / timings.length;
    const std = Math.sqrt(vr);
    const jPct = (std/avg)*100;
    measuredFPS = Math.round(1000/avg);
    document.getElementById('calib-hz').textContent      = measuredFPS + ' Hz';
    document.getElementById('calib-hz-bar').style.width  = Math.min(100,(measuredFPS/144)*100)+'%';
    document.getElementById('calib-jitter').textContent  = jPct.toFixed(1)+'% σ';
    document.getElementById('calib-jitter-bar').style.width = Math.max(0,100-jPct*10)+'%';
    document.getElementById('calib-isi').textContent     = `1 frame (~${(1000/measuredFPS).toFixed(1)} ms)`;
    const ok = measuredFPS >= 59;
    document.getElementById('calib-status').textContent  = ok ? '✓ Ready' : '⚠ Low refresh';
    document.getElementById('calib-status').style.color  = ok ? 'var(--success)' : 'var(--warning)';
    document.getElementById('calib-btns').style.opacity  = '1';
  }
  requestAnimationFrame(measure);
}
// Calibrate every time calibration screen is shown (not just once)
// Handled by showScreen() hook below

// ════════════════════════════════════════════════════════════════════
//  QUEST — Contrast-Threshold Damped Sine Surface Model
//
//  We measure the CONTRAST THRESHOLD at each SOA — the minimum contrast
//  needed to detect T2. This threshold oscillates as a damped sine:
//
//    threshold(SOA) = base + A * sin(2π * f * SOA/1000) * exp(-SOA/τ)
//
//  Convention:
//    base  = resting threshold (low contrast, easy — e.g. 5–15%)
//    A     = blink amplitude in contrast % (how much harder at trough)
//    trough peaks (sin=+1): threshold = base+A  (HIGH contrast needed)
//    recovery valleys (sin=-1): threshold ≈ base (LOW contrast, easy)
//
//  First trough ~1/(4f), second ~5/(4f), third ~9/(4f).
//  τ controls damping — free parameter so we can find 2nd/3rd troughs.
//
//  Detection likelihood uses a logistic psychometric function:
//    p(detect | SOA, contrast) = 1 / (1 + exp(-(contrast - threshold) / σ))
//  σ fixed at SIGMA_C (contrast JND slope, ~8%).
//
//  EIG jointly selects (SOA, contrast) each trial — no separate staircase.
// ════════════════════════════════════════════════════════════════════
const QUEST = (() => {
  // ── Fixed slope of psychometric function (contrast %) ────────────
  const SIGMA_C = 8.0;

  // ── Parameter grids ──────────────────────────────────────────────
  const nF   = 20;
  const fGrid = Array.from({length:nF}, (_,i) => 3.0 + i*(5.0/(nF-1)));  // 3–8 Hz

  // Amplitude: how deep the blink is in contrast % units
  // First trough threshold = base + A
  const ampGrid  = [5, 10, 18, 28, 40, 55];   // contrast %
  const nA       = ampGrid.length;

  // Base threshold: resting contrast needed outside blink
  const baseGrid = [3, 6, 10, 16, 24];         // contrast %
  const nB       = baseGrid.length;

  // Tau: decay time constant — free so 2nd/3rd troughs can emerge
  const tauGrid  = [150, 250, 400, 600, 900];  // ms
  const nT       = tauGrid.length;

  const N = nF * nA * nB * nT;
  let logPost = new Float64Array(N).fill(-Math.log(N));

  function idx(fi, ai, bi, ti) {
    return fi*(nA*nB*nT) + ai*(nB*nT) + bi*nT + ti;
  }

  // Threshold contrast at given SOA for parameter combination
  function threshold(soa_ms, fi, ai, bi, ti) {
    const f    = fGrid[fi];
    const A    = ampGrid[ai];
    const base = baseGrid[bi];
    const tau  = tauGrid[ti];
    const sine = Math.sin(2 * Math.PI * f * soa_ms / 1000);
    const env  = Math.exp(-soa_ms / tau);
    // Clamp so threshold stays in [1%, 99%]
    return Math.max(1, Math.min(99, base + A * sine * env));
  }

  // p(detect) via logistic psychometric function
  function pDet(soa_ms, contrast_pct, fi, ai, bi, ti) {
    const thr = threshold(soa_ms, fi, ai, bi, ti);
    return 1 / (1 + Math.exp(-(contrast_pct - thr) / SIGMA_C));
  }

  // Log-sum-exp for numerical stability
  function lae(a, b) {
    if (a === -Infinity) return b;
    if (b === -Infinity) return a;
    return a > b ? a + Math.log(1 + Math.exp(b-a))
                 : b + Math.log(1 + Math.exp(a-b));
  }

  // ── Posterior update ─────────────────────────────────────────────
  // Now takes contrast_pct as well as detected + soa
  function update(detected, soa_ms, contrast_pct, weight=1.0) {
    const lp = new Float64Array(N);
    for (let fi=0;fi<nF;fi++)
      for (let ai=0;ai<nA;ai++)
        for (let bi=0;bi<nB;bi++)
          for (let ti=0;ti<nT;ti++) {
            const p  = pDet(soa_ms, contrast_pct, fi, ai, bi, ti);
            const ll = detected ? Math.log(Math.max(1e-9,p))
                                : Math.log(Math.max(1e-9,1-p));
            lp[idx(fi,ai,bi,ti)] = logPost[idx(fi,ai,bi,ti)] + weight * ll;
          }
    // Normalise in log space
    let mx = -Infinity;
    lp.forEach(v => { if(v>mx) mx=v; });
    let s = 0;
    lp.forEach(v => s += Math.exp(v-mx));
    const lz = mx + Math.log(s);
    for (let i=0;i<N;i++) logPost[i] = lp[i] - lz;
  }

  // ── Marginal posteriors ───────────────────────────────────────────
  function freqPost() {
    const post = new Float64Array(nF);
    for (let fi=0;fi<nF;fi++) {
      let s = -Infinity;
      for (let ai=0;ai<nA;ai++)
        for (let bi=0;bi<nB;bi++)
          for (let ti=0;ti<nT;ti++)
            s = lae(s, logPost[idx(fi,ai,bi,ti)]);
      post[fi] = Math.exp(s);
    }
    const tot = post.reduce((a,b)=>a+b,0);
    return post.map(v=>v/tot);
  }

  function tauPost() {
    const post = new Float64Array(nT);
    for (let ti=0;ti<nT;ti++) {
      let s = -Infinity;
      for (let fi=0;fi<nF;fi++)
        for (let ai=0;ai<nA;ai++)
          for (let bi=0;bi<nB;bi++)
            s = lae(s, logPost[idx(fi,ai,bi,ti)]);
      post[ti] = Math.exp(s);
    }
    const tot = post.reduce((a,b)=>a+b,0);
    return post.map(v=>v/tot);
  }

  function meanFreq()  { const p=freqPost(); return p.reduce((m,v,i)=>m+v*fGrid[i],0); }
  function mapFreq()   { const p=freqPost(); let b=0,bv=0; p.forEach((v,i)=>{if(v>bv){bv=v;b=i;}}); return fGrid[b]; }
  function meanTau()   { const p=tauPost();  return p.reduce((m,v,i)=>m+v*tauGrid[i],0); }

  function meanParam(grid, margFn) {
    const p = margFn();
    return p.reduce((m,v,i)=>m+v*grid[i],0);
  }
  function meanAmp()  {
    const post=new Float64Array(nA);
    for(let ai=0;ai<nA;ai++){
      let s=-Infinity;
      for(let fi=0;fi<nF;fi++) for(let bi=0;bi<nB;bi++) for(let ti=0;ti<nT;ti++)
        s=lae(s,logPost[idx(fi,ai,bi,ti)]);
      post[ai]=Math.exp(s);
    }
    const tot=post.reduce((a,b)=>a+b,0);
    return post.map(v=>v/tot).reduce((m,v,i)=>m+v*ampGrid[i],0);
  }
  function meanBase() {
    const post=new Float64Array(nB);
    for(let bi=0;bi<nB;bi++){
      let s=-Infinity;
      for(let fi=0;fi<nF;fi++) for(let ai=0;ai<nA;ai++) for(let ti=0;ti<nT;ti++)
        s=lae(s,logPost[idx(fi,ai,bi,ti)]);
      post[bi]=Math.exp(s);
    }
    const tot=post.reduce((a,b)=>a+b,0);
    return post.map(v=>v/tot).reduce((m,v,i)=>m+v*baseGrid[i],0);
  }

  // ── Posterior-averaged threshold curve ───────────────────────────
  // Returns expected threshold contrast at a given SOA
  function meanThreshold(soa_ms) {
    let thr = 0;
    for(let fi=0;fi<nF;fi++)
      for(let ai=0;ai<nA;ai++)
        for(let bi=0;bi<nB;bi++)
          for(let ti=0;ti<nT;ti++)
            thr += Math.exp(logPost[idx(fi,ai,bi,ti)]) * threshold(soa_ms,fi,ai,bi,ti);
    return thr;
  }

  // ── Confidence: entropy over frequency marginal ───────────────────
  function confidence() {
    const p=freqPost(), maxH=Math.log(nF); let H=0;
    p.forEach(v=>{if(v>1e-12)H-=v*Math.log(v);});
    return Math.max(0,Math.min(1,1-H/maxH));
  }

  // ── Trough locations from posterior mean parameters ───────────────
  // Returns array of {n, soa_ms, threshold_pct} for troughs 1,2,3
  function troughs() {
    const f   = meanFreq();
    const tau = meanTau();
    const A   = meanAmp();
    const base= meanBase();
    const results = [];
    // nth trough at SOA = (4n-3)/(4f) seconds, n=1,2,3
    for (let n=1; n<=3; n++) {
      const soa_ms = (4*n-3) * 1000 / (4*f);
      const env    = Math.exp(-soa_ms/tau);
      const thr    = base + A * env; // sin=1 at trough
      results.push({ n, soa_ms: Math.round(soa_ms), threshold_pct: Math.round(thr) });
    }
    return results;
  }

  // ── Posterior-predictive p(detect) at given SOA+contrast ─────────
  function predictP(soa_ms, contrast_pct) {
    let p=0;
    for(let fi=0;fi<nF;fi++)
      for(let ai=0;ai<nA;ai++)
        for(let bi=0;bi<nB;bi++)
          for(let ti=0;ti<nT;ti++)
            p+=Math.exp(logPost[idx(fi,ai,bi,ti)])*pDet(soa_ms,contrast_pct,fi,ai,bi,ti);
    return p;
  }

  // ── EIG: jointly select best (SOA, contrast) candidate ───────────
  function entropy(dist) {
    let h=0; dist.forEach(p=>{if(p>1e-12)h-=p*Math.log(p);}); return h;
  }

  function freqEntropy() { return entropy(freqPost()); }

  // Marginal freq posterior after observing (soa, contrast, resp)
  function freqPostGiven(soa_ms, contrast_pct, resp) {
    const fp = new Float64Array(nF);
    for(let fi=0;fi<nF;fi++){
      let w=0;
      for(let ai=0;ai<nA;ai++)
        for(let bi=0;bi<nB;bi++)
          for(let ti=0;ti<nT;ti++){
            const prior = Math.exp(logPost[idx(fi,ai,bi,ti)]);
            const pd    = pDet(soa_ms, contrast_pct, fi, ai, bi, ti);
            w += prior * (resp ? pd : 1-pd);
          }
      fp[fi]=w;
    }
    const tot=fp.reduce((a,b)=>a+b,0);
    if(tot>0) for(let i=0;i<nF;i++) fp[i]/=tot;
    return fp;
  }

  // candidates: array of {soa_ms, contrast_pct}
  function nextStim(candidates) {
    const hC = freqEntropy();
    let best = candidates[0], bestEIG = -Infinity;
    candidates.forEach(c => {
      const pY  = predictP(c.soa_ms, c.contrast_pct);
      const pN  = 1 - pY;
      const eig = hC - (pY*entropy(freqPostGiven(c.soa_ms,c.contrast_pct,1))
                      + pN*entropy(freqPostGiven(c.soa_ms,c.contrast_pct,0)));
      if(eig > bestEIG){ bestEIG=eig; best=c; }
    });
    return best;
  }

  function reset() { logPost = new Float64Array(N).fill(-Math.log(N)); }

  // Legacy shim — SOA-only next (used during warm-up)
  function nextSOA(soaCands) {
    // Pick contrast at current posterior mean threshold for that SOA
    // so warm-up trials still land near the psychometric midpoint
    const c = soaCands[Math.floor(Math.random()*soaCands.length)];
    return c;
  }

  return {
    update, predictP, nextStim, nextSOA, reset,
    freqPost, tauPost, fGrid, tauGrid, nF, nT,
    meanFreq, mapFreq, meanTau, meanAmp, meanBase, meanThreshold,
    troughs, confidence, SIGMA_C
  };
})();

// ════════════════════════════════════════════════════════════════════
//  CANDIDATE GRID — (SOA × contrast) pairs for EIG selection
//  Built once per session after calibration, updated if CFG changes.
// ════════════════════════════════════════════════════════════════════
let stimCandidates = [];  // [{soa_ms, contrast_pct}, ...]

function buildStimCandidates(mspf) {
  const minFrames = Math.ceil(50  / mspf);
  const maxFrames = Math.ceil(CFG.soaMaxMs / mspf);
  const soaCands  = [];
  for(let f=minFrames; f<=maxFrames; f++) soaCands.push(Math.round(f*mspf));
  const uniqueSOAs = [...new Set(soaCands)];

  // Contrast levels: 5–95%, log-spaced to concentrate near low values
  // where the interesting threshold region lives
  const contrastLevels = [];
  const nC = 12;
  for(let i=0;i<nC;i++){
    const pct = Math.round(5 * Math.pow(95/5, i/(nC-1)));
    contrastLevels.push(Math.max(5, Math.min(95, pct)));
  }
  const uniqueContrasts = [...new Set(contrastLevels)];

  const cands = [];
  uniqueSOAs.forEach(soa => {
    uniqueContrasts.forEach(c => cands.push({soa_ms: soa, contrast_pct: c}));
  });
  return cands;
}

// Current trial's assigned stimulus (set by startTrial / finishTrial)
let currentContrast_pct = 40;

function resetStaircases() { /* no separate staircase — QUEST handles everything */ }
// Legacy alias
function resetBinStaircases() { resetStaircases(); }

// ════════════════════════════════════════════════════════════════════
//  SETTINGS
// ════════════════════════════════════════════════════════════════════
let CFG = {
  framesPerItem:  8,       // stream speed (~67ms @ 120Hz)
  t1FontPx:       96,
  soaMaxMs:       800,     // extend to 800ms to capture 2nd trough
  totalTrials:    120,
  maskEnabled:    false,   // line fragment mask after digits (toggle)
};

let FRAMES_PER_ITEM = CFG.framesPerItem;
let STIM_FRAMES     = CFG.framesPerItem;
let TOTAL_TRIALS    = CFG.totalTrials;
let T1_FONT_FACE    = `bold ${CFG.t1FontPx}px Arial, Helvetica, sans-serif`;

function grayToHex(g) {
  const h = Math.max(0,Math.min(255,Math.round(g))).toString(16).padStart(2,'0');
  return '#' + h + h + h;
}

function getEl(id) { return document.getElementById(id); }
function setLbl(id, val) { const e=getEl(id); if(e) e.textContent=val; }

function updateSettings() {
  const speed = getEl('sl-speed');
  if (speed) { CFG.framesPerItem = parseInt(speed.value); setLbl('lbl-speed', Math.round(CFG.framesPerItem*(1000/120))+'ms/item'); }

  const font = getEl('sl-t1font');
  if (font) { CFG.t1FontPx = parseInt(font.value); setLbl('lbl-t1font', CFG.t1FontPx+'px'); }

  const soa = getEl('sl-soamax');
  if (soa) { CFG.soaMaxMs = parseInt(soa.value); setLbl('lbl-soamax', CFG.soaMaxMs+'ms'); }

  const tr = getEl('sl-trials');
  if (tr) { CFG.totalTrials = parseInt(tr.value); setLbl('lbl-trials', CFG.totalTrials); }

  const mask = getEl('chk-mask');
  if (mask) { CFG.maskEnabled = mask.checked; }
}

function applySettings() {
  FRAMES_PER_ITEM = CFG.framesPerItem;
  STIM_FRAMES     = CFG.framesPerItem;
  TOTAL_TRIALS    = CFG.totalTrials;
  T1_FONT_FACE    = `bold ${CFG.t1FontPx}px Arial, Helvetica, sans-serif`;
}

function initSettings() { updateSettings(); }

// ════════════════════════════════════════════════════════════════════
//  STREAM CONSTANTS
// ════════════════════════════════════════════════════════════════════
const BG_COLOR     = 'rgb(128,128,128)';
const DIST_COLOR   = '#222222';
const T1_COLOR     = '#d8d8d8';  // white-ish, clearly distinct
const FIX_COLOR    = '#1a1a1a';
const DIST_FONT    = 'bold 108px Arial, Helvetica, sans-serif';

// T1 digits: 1-4, T2 digits: 6-9 (distinct ranges, same Low/High task)
const T1_POOL = ['1','2','3','4'];
const T2_POOL = ['6','7','8','9'];
const LETTER_POOL = ['K','V','Y','Z','N','W','M','H','I','T','F','E','L','J','P','R','U','C'];

const RUNOUT_ITEMS  = 6;  // items after T2 (extends backward mask)
const PRE_T1_MIN    = 5;  // min distractor items before T1
const PRE_T1_MAX    = 9;  // max distractor items before T1

// ════════════════════════════════════════════════════════════════════
//  LINE FRAGMENT MASK
//  Fired for one frame immediately after T1 and T2 item slots.
// ════════════════════════════════════════════════════════════════════
function drawLineMask(ctx, cx, cy, radius=55) {
  ctx.save();
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 3;
  for (let i = 0; i < 7; i++) {
    const angle = Math.random() * Math.PI * 2;
    const len   = 20 + Math.random() * 35;
    const ox    = (Math.random() - 0.5) * radius * 1.6;
    const oy    = (Math.random() - 0.5) * radius * 1.6;
    ctx.beginPath();
    ctx.moveTo(cx + ox, cy + oy);
    ctx.lineTo(cx + ox + Math.cos(angle)*len, cy + oy + Math.sin(angle)*len);
    ctx.stroke();
  }
  ctx.restore();
}

// ════════════════════════════════════════════════════════════════════
//  SESSION STATE
// ════════════════════════════════════════════════════════════════════
let canvas, ctx, animFrame;
let sessionActive   = false;
let trials          = [];
let currentTrial    = 0;
let probeHits       = {}, probeMisses = {}, probeContrasts = {};
let t1RTs           = [];  // all valid T1 RTs for sigmoid calibration
let medianT1RT      = 300; // running median T1 RT (ms), updated each trial

const DEBUG_MODE = location.search.includes('debug');
let msPerFrame    = 1000 / 120;

// Per-trial state
let phase         = 'idle';
let phaseFrame    = 0;
let currentItem   = null;
let maskFrame     = false;  // true for the one-frame mask after a digit
let t1Onset       = 0;      // performance.now() when T1 appeared
let t2Onset       = 0;      // performance.now() when T2 appeared
let t1Tapped      = false;
let t2Tapped      = false;
let t1RT          = null;   // ms
let t2RT          = null;   // ms
let t1WinOpen     = false;
let t2WinOpen     = false;
let t1WinTimeout  = null;
let t2WinTimeout  = null;
let currentSOA_ms = 0;
let currentT2Color= '#808080';
let lagItems      = 0;
let lagItemsDone  = 0;
let runoutDone    = 0;
let preItemsDone  = 0;
let preItemsTarget= 0;



function countdown(n, cb) {
  if (n <= 0) { cb(); return; }
  drawBg();
  if (!ctx) return;
  const W=canvas.width/devicePixelRatio, H=canvas.height/devicePixelRatio;
  ctx.fillStyle=T1_COLOR; ctx.font='bold 72px Arial';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(n, W/2, H/2);
  setTimeout(() => countdown(n-1, cb), 900);
}

// ════════════════════════════════════════════════════════════════════
//  TAP HANDLER — single button
//  Stream runs autonomously at fixed SOA regardless of tapping.
//  Tap 1 (after T1 onset) = "saw T1"   → records T1 RT
//  Tap 2 (after T2 onset) = "saw T2"   → records T2 RT
//  Both taps may arrive during runout or even after stream ends.
//  1 tap only = T1 seen, T2 missed. 2 taps = both seen.
// ════════════════════════════════════════════════════════════════════
function handleTap() {
  if (!sessionActive) return;
  const now = performance.now();

  // Brief bottom-bar flash
  const ind = document.getElementById('tap-indicator');
  ind.classList.add('tapped');
  setTimeout(() => ind.classList.remove('tapped'), 100);

  // First tap after T1 onset
  if (t1WinOpen && !t1Tapped) {
    t1Tapped = true;
    t1RT     = now - t1Onset;
    document.getElementById('hud-t1rt').textContent = Math.round(t1RT) + 'ms';
    return;
  }

  // Second tap after T2 onset
  if (t2WinOpen && !t2Tapped) {
    t2Tapped = true;
    t2RT     = now - t2Onset;
    playBeep();
    return;
  }
}

function openT1Window() {
  // Called at T1 onset. Stream continues independently.
  t1WinOpen = true;
}

function openT2Window() {
  // Called at T2 onset (fixed SOA after T1 onset, stream-driven).
  // Window stays open through runout and until next trial starts.
  t2WinOpen = true;
}

// ════════════════════════════════════════════════════════════════════
//  SESSION START
// ════════════════════════════════════════════════════════════════════
function startSession() {
  applySettings();
  QUEST.reset();
  resetBinStaircases();
  trials=[]; currentTrial=0;
  probeHits={}; probeMisses={}; probeContrasts={};
  t1RTs=[]; medianT1RT=300;

  canvas = document.getElementById('task-canvas');
  ctx    = canvas.getContext('2d');
  function resizeCanvas() {
    canvas.width  = window.innerWidth  * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    canvas.style.width  = window.innerWidth  + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  msPerFrame     = 1000 / (measuredFPS || 120);
  stimCandidates = buildStimCandidates(msPerFrame);

  // Pre-assign stimuli for all trials
  // Warm-up (first 15): random SOA, contrast starts at 40% (visible) and adapts
  for (let i=0; i<TOTAL_TRIALS; i++) {
    let stim;
    if (i < 15) {
      // Random SOA, moderate contrast so participant can find the task
      const soaList = [...new Set(stimCandidates.map(c=>c.soa_ms))];
      const soa     = soaList[Math.floor(Math.random()*soaList.length)];
      stim = { soa_ms: soa, contrast_pct: 40 };
    } else {
      stim = QUEST.nextStim(stimCandidates);
    }
    trials.push({ soa_ms: stim.soa_ms, contrast_pct: stim.contrast_pct,
                  detected: null, t1RT: null, t2RT: null,
                  t2Contrast: null, t1Tapped: false });
  }

  document.getElementById('tap-overlay').style.display = 'block';
  showScreen('task-screen');
  countdown(3, () => { sessionActive = true; startTrial(); });
}

function abortSession() {
  sessionActive = false;
  if (animFrame) cancelAnimationFrame(animFrame);
  clearTimeout(t1WinTimeout);
  document.getElementById('tap-overlay').style.display = 'none';
  showScreen('home-screen');
}

// ════════════════════════════════════════════════════════════════════
//  TRIAL ENGINE — Stream state machine
//  Phases: pre → t1 → mask_t1 → lag → t2 → mask_t2 → runout → done
// ════════════════════════════════════════════════════════════════════
function startTrial() {
  if (!sessionActive || currentTrial >= TOTAL_TRIALS) { endSession(); return; }

  const trial = trials[currentTrial];
  currentSOA_ms  = trial.soa_ms;
  // lagItems = distractor items between T1 offset and T2 onset
  // SOA_frames = round(SOA_ms / msPerFrame); T1 takes FRAMES_PER_ITEM frames.
  // Remaining frames after T1 = SOA_frames - FRAMES_PER_ITEM.
  // Whole distractor items that fit = floor of that / FRAMES_PER_ITEM.
  lagItems = Math.max(0, Math.floor(
    (Math.round(currentSOA_ms / msPerFrame) - FRAMES_PER_ITEM) / FRAMES_PER_ITEM
  ));
  lagItemsDone   = 0;
  runoutDone     = 0;
  preItemsDone   = 0;
  preItemsTarget = PRE_T1_MIN + Math.floor(Math.random() * (PRE_T1_MAX - PRE_T1_MIN + 1));
  t1Tapped  = false; t2Tapped  = false;
  t1RT      = null;  t2RT      = null;
  t1WinOpen = false; t2WinOpen = false;
  maskFrame = false;
  phase     = 'pre';
  phaseFrame= 0;

  // Get contrast assigned by QUEST for this trial
  currentContrast_pct = trial.contrast_pct !== undefined ? trial.contrast_pct : 40;
  currentT2Color      = contrastToHex(currentContrast_pct);
  trial.t2Contrast    = currentContrast_pct;

  // Pick T1 digit (1-4) and T2 digit (6-9)
  const t1Char = T1_POOL[Math.floor(Math.random() * T1_POOL.length)];
  const t2Char = T2_POOL[Math.floor(Math.random() * T2_POOL.length)];
  trial.t1Char = t1Char;
  trial.t2Char = t2Char;

  // Reset windows — close any stale windows from previous trial
  t1WinOpen = false; t2WinOpen = false;
  document.getElementById('tap-indicator').classList.remove('tapped');
  document.getElementById('hud-contrast').textContent = contrastPct.toFixed(0) + '%';

  currentItem = { char: pickLetter(), color: DIST_COLOR, role: 'dist' };
  if (animFrame) cancelAnimationFrame(animFrame);
  animFrame = requestAnimationFrame(streamLoop);
}

function pickLetter() {
  return LETTER_POOL[Math.floor(Math.random() * LETTER_POOL.length)];
}

// ── Stream loop ────────────────────────────────────────────────────
function streamLoop() {
  if (!sessionActive) return;
  phaseFrame++;

  switch(phase) {

    case 'pre':
      drawItemFrame();
      if (phaseFrame >= FRAMES_PER_ITEM) {
        phaseFrame = 0; preItemsDone++;
        if (preItemsDone >= preItemsTarget) {
          // Fire T1
          phase = 't1';
          const t = trials[currentTrial];
          currentItem = { char: t.t1Char, color: T1_COLOR, role: 't1',
                          font: T1_FONT_FACE };
        } else {
          currentItem = { char: pickLetter(), color: DIST_COLOR, role: 'dist' };
        }
      }
      break;

    case 't1':
      drawItemFrame();
      if (phaseFrame === 1) {
        // T1 onset
        t1Onset = performance.now();
        openT1Window();
      }
      if (phaseFrame >= FRAMES_PER_ITEM) {
        // T1 done — fire line mask for 1 frame
        phase = 'mask_t1'; phaseFrame = 0;
        maskFrame = true;
      }
      break;

    case 'mask_t1': {
      drawBg();
      if (CFG.maskEnabled) {
        const W1 = canvas.width/devicePixelRatio, H1 = canvas.height/devicePixelRatio;
        drawLineMask(ctx, W1/2, H1/2);
      }
      maskFrame = false;
      phase = lagItems > 0 ? 'lag' : 't2';
      phaseFrame = 0;
      currentItem = { char: pickLetter(), color: DIST_COLOR, role: 'dist' };
      break;
    }

    case 'lag':
      drawItemFrame();
      if (phaseFrame >= FRAMES_PER_ITEM) {
        phaseFrame = 0; lagItemsDone++;
        if (lagItemsDone >= lagItems) {
          phase = 't2'; phaseFrame = 0;
          const t = trials[currentTrial];
          currentItem = { char: t.t2Char, color: currentT2Color, role: 't2',
                          font: DIST_FONT };
        } else {
          currentItem = { char: pickLetter(), color: DIST_COLOR, role: 'dist' };
        }
      }
      break;

    case 't2':
      drawItemFrame();
      if (phaseFrame === 1) {
        t2Onset = performance.now();
        openT2Window();
      }
      if (phaseFrame >= FRAMES_PER_ITEM) {
        phase = 'mask_t2'; phaseFrame = 0;
        maskFrame = true;
      }
      break;

    case 'mask_t2': {
      drawBg();
      if (CFG.maskEnabled) {
        const W2 = canvas.width/devicePixelRatio, H2 = canvas.height/devicePixelRatio;
        drawLineMask(ctx, W2/2, H2/2);
      }
      maskFrame = false;
      phase = 'runout'; phaseFrame = 0;
      currentItem = { char: pickLetter(), color: DIST_COLOR, role: 'dist' };
      break;
    }

    case 'runout':
      drawItemFrame();
      if (phaseFrame >= FRAMES_PER_ITEM) {
        phaseFrame = 0; runoutDone++;
        if (runoutDone >= RUNOUT_ITEMS) {
          // Stream done — close any open windows and finish
          t1WinOpen = false;
          t2WinOpen = false;
          if (!t1Tapped) { discardTrial(); return; }
          finishTrial();
          return;
        } else {
          currentItem = { char: pickLetter(), color: DIST_COLOR, role: 'dist' };
        }
      }
      break;
  }

  animFrame = requestAnimationFrame(streamLoop);
}

function drawBg() {
  if (!ctx) return;
  const W = canvas.width/devicePixelRatio, H = canvas.height/devicePixelRatio;
  ctx.fillStyle = BG_COLOR;
  ctx.fillRect(0, 0, W, H);
  // Fixation cross
  ctx.strokeStyle = FIX_COLOR; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(W/2-10,H/2); ctx.lineTo(W/2+10,H/2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W/2,H/2-10); ctx.lineTo(W/2,H/2+10); ctx.stroke();
}

function drawItemFrame() {
  drawBg();
  if (currentItem && phaseFrame <= STIM_FRAMES) drawItem(currentItem);
}

function drawItem(item) {
  const W = canvas.width/devicePixelRatio, H = canvas.height/devicePixelRatio;
  ctx.font = item.font || DIST_FONT;
  ctx.fillStyle = item.color;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(item.char, W/2, H/2);
}

// ════════════════════════════════════════════════════════════════════
//  TRIAL COMPLETION
// ════════════════════════════════════════════════════════════════════
function discardTrial() {
  // T1 not tapped — trial invalid, redo slot
  if (animFrame) cancelAnimationFrame(animFrame);
  trials[currentTrial].detected = null; // mark invalid
  currentTrial++;
  if (currentTrial >= TOTAL_TRIALS) { endSession(); return; }
  updateHUD();
  drawBg();
  setTimeout(startTrial, 300);
}

function finishTrial() {
  if (animFrame) cancelAnimationFrame(animFrame);
  if (!sessionActive) return;

  const trial   = trials[currentTrial];
  const detected = t2Tapped;

  trial.detected   = detected;
  trial.t1Tapped   = t1Tapped;
  trial.t1RT       = t1RT;
  trial.t2RT       = t2RT;

  if (!t1Tapped) {
    // T1 not acknowledged — discard (don't feed QUEST)
    trial.valid = false;
  } else {
    trial.valid = true;
    const soa = currentSOA_ms;

    // Update T1 RT running median
    if (t1RT !== null) {
      t1RTs.push(t1RT);
      t1RTs.sort((a,b)=>a-b);
      medianT1RT = t1RTs[Math.floor(t1RTs.length/2)];
    }

    // T1 RT weight: sigmoid centred on medianT1RT
    // Fast RT (half median) → weight ~0.9, slow RT (2x median) → weight ~0.5
    const t1Weight = t1RT !== null
      ? 0.5 + 0.45 * (1 / (1 + Math.exp((t1RT - medianT1RT) / (medianT1RT * 0.4))))
      : 0.7;

    // Feed QUEST: (detected, soa, contrast, weight)
    QUEST.update(detected ? 1 : 0, soa, trial.t2Contrast, t1Weight);

    // Track for chart
    if (!probeHits[soa])   { probeHits[soa]=0; probeMisses[soa]=0; probeContrasts[soa]=[]; }
    if (detected) probeHits[soa]++; else probeMisses[soa]++;
    probeContrasts[soa].push(trial.t2Contrast);

    // Pre-assign next trial stimulus via EIG (after warm-up)
    const ni = currentTrial + 1;
    if (ni < TOTAL_TRIALS && trials[ni] && trials[ni].soa_ms !== null) {
      if (ni >= 15) {
        const stim = QUEST.nextStim(stimCandidates);
        trials[ni].soa_ms       = stim.soa_ms;
        trials[ni].contrast_pct = stim.contrast_pct;
      }
    }
  }

  currentTrial++;
  updateHUD();
  drawBg();
  if (currentTrial >= TOTAL_TRIALS) { endSession(); return; }

  // Brief gap then next trial (no ITI — just enough for buttons to reset visually)
  setTimeout(startTrial, 200 + Math.random()*150);
}

function updateHUD() {
  document.getElementById('hud-trial').textContent = `${currentTrial} / ${TOTAL_TRIALS}`;
  const c = (QUEST.confidence()*100).toFixed(0);
  document.getElementById('hud-conf').style.width = c + '%';
  if (medianT1RT) {
    document.getElementById('hud-t1rt').textContent = Math.round(medianT1RT) + 'ms';
  }
}

// ════════════════════════════════════════════════════════════════════
//  AUDIO
// ════════════════════════════════════════════════════════════════════
let audioCtx = null;
function playBeep() {
  try {
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if(audioCtx.state==='suspended') audioCtx.resume();
    const osc=audioCtx.createOscillator(), gain=audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.type='sine'; osc.frequency.setValueAtTime(880, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime+0.08);
    osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime+0.08);
  } catch(e) {}
}

// ════════════════════════════════════════════════════════════════════
//  END SESSION & RESULTS
// ════════════════════════════════════════════════════════════════════
function endSession() {
  sessionActive = false;
  if (animFrame) cancelAnimationFrame(animFrame);
  window.removeEventListener('resize', ()=>{});
  document.getElementById('tap-overlay').style.display = 'none';

  const thetaHz   = QUEST.meanFreq();
  const thetaMAP  = QUEST.mapFreq();
  const tauMs     = QUEST.meanTau();
  const ampVal    = QUEST.meanAmp();    // contrast % amplitude
  const baseC     = QUEST.meanBase();   // baseline threshold contrast %
  const troughData= QUEST.troughs();   // [{n, soa_ms, threshold_pct}, ...]
  const trough1   = troughData[0];
  const trough2   = troughData[1];
  const trough3   = troughData[2];

  const conf      = QUEST.confidence();
  const confPct   = (conf*100).toFixed(0);
  const confLabel = conf<0.3?'Low':conf<0.55?'Moderate':conf<0.78?'Good':'High';
  const confColor = conf<0.3?'var(--danger)':conf<0.55?'var(--warning)':conf<0.78?'var(--theta)':'var(--success)';

  document.getElementById('res-hz').textContent      = thetaHz.toFixed(2);
  document.getElementById('res-unit').textContent    = `Hz  ·  MAP ${thetaMAP.toFixed(2)} Hz`;
  document.getElementById('res-period').textContent  = `${trough1.soa_ms} ms  ·  τ=${Math.round(tauMs)} ms`;
  document.getElementById('res-depth').textContent   = `${trough1.threshold_pct}% / ${trough2.threshold_pct}% / ${trough3.threshold_pct}%`;
  document.getElementById('res-baseline').textContent= `${baseC.toFixed(1)}% contrast`;
  document.getElementById('res-tau').textContent     = `A=${ampVal.toFixed(1)}%`;
  document.getElementById('conf-bar').style.width    = confPct + '%';
  document.getElementById('conf-label').textContent  = `${confLabel} · ${confPct}%`;
  document.getElementById('conf-label').style.color  = confColor;

  const validTrials = trials.filter(t=>t.valid).length;
  const discarded   = trials.filter(t=>t.valid===false).length;
  const t1RTMean    = t1RTs.length ? Math.round(t1RTs.reduce((a,b)=>a+b,0)/t1RTs.length) : '—';

  const freqInterp = thetaHz > 6.5
    ? 'Fast theta — short cycle, troughs arrive early.'
    : thetaHz < 3.5
    ? 'Slow theta — long cycle, deep single blink, late recovery.'
    : 'Mid-range theta — canonical AB range (Bonnefond & Jensen 2012).';

  const tauInterp = tauMs > 600
    ? 'Long decay — 2nd and 3rd troughs likely visible.'
    : tauMs > 300
    ? 'Moderate decay — 2nd trough shallow but measurable.'
    : 'Short decay — blink resolves quickly, 2nd trough near floor.';

  document.getElementById('blink-interp').innerHTML =
    `<strong>${thetaHz.toFixed(2)} Hz</strong> theta (MAP: ${thetaMAP.toFixed(2)} Hz) · τ=${Math.round(tauMs)} ms decay. ` +
    `<br>Trough thresholds — ` +
    `T1: <strong>${trough1.threshold_pct}%</strong> contrast @ ${trough1.soa_ms} ms · ` +
    `T2: <strong>${trough2.threshold_pct}%</strong> @ ${trough2.soa_ms} ms · ` +
    `T3: <strong>${trough3.threshold_pct}%</strong> @ ${trough3.soa_ms} ms. ` +
    `Baseline: ${baseC.toFixed(1)}%. Amplitude: ${ampVal.toFixed(1)}%. ` +
    `<br>${freqInterp} ${tauInterp}` +
    `<br><br>Valid: <strong>${validTrials}</strong>/${TOTAL_TRIALS} (${discarded} discarded). ` +
    `Mean T1 RT: <strong>${t1RTMean} ms</strong>. ` +
    `Confidence: <strong style="color:${confColor}">${confLabel} (${confPct}%)</strong>. ` +
    `${conf<0.5?'Posterior broad — run more trials.':'Posterior focused.'}`;

  drawSOAChart(baseC, trough1.soa_ms);
  drawContrastChart();
  drawFreqChart();
  saveResult(thetaHz, thetaMAP, trough1.soa_ms, trough2.soa_ms, ampVal, baseC.toFixed(1), trough1.threshold_pct, trough2.threshold_pct, confPct);
  showScreen('results-screen');
}

// ════════════════════════════════════════════════════════════════════
//  CHARTS
// ════════════════════════════════════════════════════════════════════
function drawSOAChart(baseP, troughMs) {
  const el=document.getElementById('soa-chart');
  const ctx2=el.getContext('2d');
  const W=el.parentElement.offsetWidth-2, H=170;
  el.width=W*devicePixelRatio; el.height=H*devicePixelRatio;
  el.style.width=W+'px'; el.style.height=H+'px';
  ctx2.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  ctx2.clearRect(0,0,W,H);
  const pad={l:36,r:12,t:12,b:30};
  const cW=W-pad.l-pad.r, cH=H-pad.t-pad.b;
  // Y axis: threshold contrast % (0 at bottom = easy/low threshold, 100=hard)
  for(let i=0;i<=4;i++){
    const y=pad.t+cH*(1-i/4);
    ctx2.strokeStyle='rgba(28,28,46,1)'; ctx2.lineWidth=1;
    ctx2.beginPath();ctx2.moveTo(pad.l,y);ctx2.lineTo(pad.l+cW,y);ctx2.stroke();
    ctx2.fillStyle='rgba(90,90,122,0.65)';ctx2.font='8px Space Mono';ctx2.textAlign='right';
    ctx2.fillText((i*25)+'%c',pad.l-3,y+3);
  }
  const keys=Object.keys(probeHits).map(Number).sort((a,b)=>a-b);
  if(keys.length<2) return;
  const modelMin=50, modelMax=600, mR=modelMax-modelMin;
  const msx=s=>pad.l+(s-modelMin)/mR*cW;
  const py=p=>pad.t+cH*(1-p);
  // Draw posterior-mean threshold curve (contrast % on Y axis)
  ctx2.strokeStyle='rgba(0,229,255,0.7)';ctx2.lineWidth=2;ctx2.setLineDash([]);
  ctx2.beginPath();let first=true;
  for(let s=modelMin;s<=modelMax;s+=4){
    const thr=QUEST.meanThreshold(s),x=msx(s),y=py(thr/100);
    first?ctx2.moveTo(x,y):ctx2.lineTo(x,y);first=false;
  }
  ctx2.stroke();
  // Mark trough 1 and trough 2
  const tr=QUEST.troughs();
  [tr[0],tr[1]].forEach((t,i)=>{
    if(t.soa_ms<modelMin||t.soa_ms>modelMax) return;
    ctx2.strokeStyle=i===0?'rgba(255,157,0,0.6)':'rgba(255,60,90,0.5)';;
    ctx2.lineWidth=1;ctx2.setLineDash([3,3]);
    ctx2.beginPath();ctx2.moveTo(msx(t.soa_ms),pad.t);ctx2.lineTo(msx(t.soa_ms),pad.t+cH);ctx2.stroke();
    ctx2.setLineDash([]);
    ctx2.fillStyle=i===0?'rgba(255,157,0,0.8)':'rgba(255,60,90,0.7)';
    ctx2.font='8px Space Mono';ctx2.textAlign='center';
    ctx2.fillText('T'+(i+1),msx(t.soa_ms),pad.t+8);
  });
  // Baseline threshold
  ctx2.strokeStyle='rgba(57,255,138,0.38)';ctx2.lineWidth=1;ctx2.setLineDash([2,4]);
  ctx2.beginPath();ctx2.moveTo(pad.l,py(baseP/100));ctx2.lineTo(pad.l+cW,py(baseP/100));ctx2.stroke();
  ctx2.setLineDash([]);
  // Plot mean contrast used at each SOA (approximates threshold)
  keys.forEach(soa=>{
    const tot=(probeHits[soa]||0)+(probeMisses[soa]||0);
    if(!tot) return;
    const contrasts = probeContrasts[soa]||[];
    if(!contrasts.length) return;
    const meanC = contrasts.reduce((a,b)=>a+b,0)/contrasts.length;
    const x=msx(soa), y=py(meanC/100), r=Math.max(3,Math.min(8,tot));
    ctx2.fillStyle='rgba(0,229,255,0.15)';ctx2.beginPath();ctx2.arc(x,y,r,0,Math.PI*2);ctx2.fill();
    ctx2.strokeStyle='#00e5ff';ctx2.lineWidth=1.5;ctx2.beginPath();ctx2.arc(x,y,r,0,Math.PI*2);ctx2.stroke();
    // detection rate as label inside dot
    const pDet=(probeHits[soa]||0)/tot;
    ctx2.fillStyle='rgba(0,229,255,0.8)';ctx2.font='7px Space Mono';ctx2.textAlign='center';
    ctx2.fillText(Math.round(pDet*100)+'%',x,y+2.5);
  });
  ctx2.fillStyle='rgba(90,90,122,0.6)';ctx2.font='8px Space Mono';ctx2.textAlign='center';
  [50,150,300,450,600].forEach(s=>ctx2.fillText(s+'ms',msx(s),pad.t+cH+19));
  ctx2.fillStyle='rgba(0,229,255,0.6)';ctx2.textAlign='right';ctx2.fillText('— threshold',pad.l+cW,pad.t+10);
  ctx2.fillStyle='rgba(57,255,138,0.45)';ctx2.fillText('— base',pad.l+cW,pad.t+21);
  ctx2.fillStyle='rgba(255,157,0,0.7)';ctx2.fillText('T1/T2 troughs',pad.l+cW,pad.t+32);
}

function drawContrastChart() {
  // Shows the posterior mean threshold curve overlaid with empirical
  // scatter of (SOA, contrast) trials coloured by detection outcome.
  const el=document.getElementById('contrast-chart');
  const ctx2=el.getContext('2d');
  const W=el.parentElement.offsetWidth-2, H=150;
  el.width=W*devicePixelRatio; el.height=H*devicePixelRatio;
  el.style.width=W+'px'; el.style.height=H+'px';
  ctx2.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  ctx2.clearRect(0,0,W,H);
  const pad={l:36,r:12,t:14,b:30};
  const cW=W-pad.l-pad.r, cH=H-pad.t-pad.b;
  const modelMin=50, modelMax=CFG.soaMaxMs, mR=modelMax-modelMin;
  const maxC=100;
  const msx=s=>pad.l+(s-modelMin)/mR*cW;
  const cy=c=>pad.t+cH*(1-c/maxC);

  // Grid lines
  for(let i=0;i<=4;i++){
    const y=pad.t+cH*(1-i/4);
    ctx2.strokeStyle='rgba(28,28,46,1)';ctx2.lineWidth=1;
    ctx2.beginPath();ctx2.moveTo(pad.l,y);ctx2.lineTo(pad.l+cW,y);ctx2.stroke();
    ctx2.fillStyle='rgba(90,90,122,0.65)';ctx2.font='8px Space Mono';ctx2.textAlign='right';
    ctx2.fillText((i*25)+'%',pad.l-3,y+3);
  }

  // Posterior mean threshold curve
  ctx2.strokeStyle='rgba(0,229,255,0.7)';ctx2.lineWidth=2;ctx2.setLineDash([]);
  ctx2.beginPath();let first=true;
  for(let s=modelMin;s<=modelMax;s+=5){
    const thr=QUEST.meanThreshold(s),x=msx(s),y=cy(thr);
    first?ctx2.moveTo(x,y):ctx2.lineTo(x,y);first=false;
  }
  ctx2.stroke();

  // Trough markers
  const tr=QUEST.troughs();
  [[tr[0],'rgba(255,157,0,0.7)','T1'],[tr[1],'rgba(255,60,90,0.6)','T2']].forEach(([t,col,lbl])=>{
    if(t.soa_ms<modelMin||t.soa_ms>modelMax) return;
    ctx2.strokeStyle=col;ctx2.lineWidth=1;ctx2.setLineDash([3,3]);
    ctx2.beginPath();ctx2.moveTo(msx(t.soa_ms),pad.t);ctx2.lineTo(msx(t.soa_ms),pad.t+cH);ctx2.stroke();
    ctx2.setLineDash([]);
    ctx2.fillStyle=col;ctx2.font='bold 8px Space Mono';ctx2.textAlign='center';
    ctx2.fillText(lbl+' '+t.threshold_pct+'%',msx(t.soa_ms),pad.t+8);
  });

  // Empirical scatter: each trial as a dot, hit=cyan, miss=red
  trials.forEach(t=>{
    if(!t.valid||t.t2Contrast===null||t.soa_ms===null) return;
    if(t.soa_ms<modelMin||t.soa_ms>modelMax) return;
    const x=msx(t.soa_ms), y=cy(t.t2Contrast);
    ctx2.fillStyle=t.detected?'rgba(0,229,255,0.35)':'rgba(255,60,90,0.35)';
    ctx2.beginPath();ctx2.arc(x,y,3,0,Math.PI*2);ctx2.fill();
  });

  // X axis labels
  ctx2.fillStyle='rgba(90,90,122,0.6)';ctx2.font='8px Space Mono';ctx2.textAlign='center';
  const xTicks=[100,200,300,400,500,600,700,800].filter(s=>s<=modelMax);
  xTicks.forEach(s=>ctx2.fillText(s+'ms',msx(s),pad.t+cH+19));

  // Legend
  ctx2.fillStyle='rgba(0,229,255,0.6)';ctx2.textAlign='right';
  ctx2.fillText('— threshold',pad.l+cW,pad.t+10);
  ctx2.fillStyle='rgba(0,229,255,0.5)';
  ctx2.fillText('● hit',pad.l+cW,pad.t+21);
  ctx2.fillStyle='rgba(255,60,90,0.6)';
  ctx2.fillText('● miss',pad.l+cW-30,pad.t+21);
}

function drawFreqChart() {
  const el=document.getElementById('freq-chart');
  const ctx2=el.getContext('2d');
  const W=el.parentElement.offsetWidth-2, H=100;
  el.width=W*devicePixelRatio; el.height=H*devicePixelRatio;
  el.style.width=W+'px'; el.style.height=H+'px';
  ctx2.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  ctx2.clearRect(0,0,W,H);
  const post=QUEST.freqPost(), grid=QUEST.fGrid, nF=QUEST.nF;
  const pad={l:26,r:10,t:12,b:22};
  const cW=W-pad.l-pad.r, cH=H-pad.t-pad.b;
  const maxP=Math.max(...post)||1, bw=cW/nF*0.78;
  post.forEach((p,i)=>{
    const x=pad.l+(i+0.5)*cW/nF-bw/2, bh=(p/maxP)*cH;
    ctx2.fillStyle=`rgba(0,229,255,${(0.15+p/maxP*0.75).toFixed(2)})`;
    ctx2.fillRect(x,pad.t+cH-bh,bw,bh);
  });
  const mapF=QUEST.mapFreq();
  const mapI=grid.reduce((bi,v,i)=>Math.abs(v-mapF)<Math.abs(grid[bi]-mapF)?i:bi,0);
  const mx=pad.l+(mapI+0.5)*cW/nF;
  ctx2.strokeStyle='rgba(0,229,255,0.9)';ctx2.lineWidth=1.5;
  ctx2.beginPath();ctx2.moveTo(mx,pad.t);ctx2.lineTo(mx,pad.t+cH);ctx2.stroke();
  ctx2.fillStyle='var(--theta)';ctx2.font='bold 9px Space Mono';ctx2.textAlign='center';
  ctx2.fillText(mapF.toFixed(1)+'Hz',mx,pad.t+8);
  ctx2.fillStyle='rgba(90,90,122,0.55)';ctx2.font='8px Space Mono';ctx2.textAlign='center';
  [0,Math.floor(nF/2),nF-1].forEach(i=>ctx2.fillText(grid[i].toFixed(1)+'Hz',pad.l+(i+0.5)*cW/nF,pad.t+cH+14));
}

// ════════════════════════════════════════════════════════════════════
//  CSV EXPORT
// ════════════════════════════════════════════════════════════════════
function downloadCSV() {
  let csv = 'Trial,SOA_ms,T2_Contrast_pct,T1_Char,T2_Char,T1_Tapped,T1_RT_ms,T2_Detected,T2_RT_ms,Valid\n';
  trials.forEach((t,i) => {
    if (t.detected === null && t.valid !== false) return;
    csv += `${i+1},${t.soa_ms??''},${t.t1Char??''},${t.t2Char??''},` +
           `${t.t1Tapped?1:0},${t.t1RT!==null?Math.round(t.t1RT):''},` +
           `${t.detected?1:0},${t.t2RT!==null?Math.round(t.t2RT):''},` +
           `${t.t2Contrast!==null?t.t2Contrast.toFixed(1):''},${t.valid?1:0}\n`;
  });
  csv += `\nSummary\n`;
  csv += `Paradigm,Twitch v2.0\n`;
  csv += `Model,Damped Sine (tau=250ms)\n`;
  const tr = QUEST.troughs();
  csv += `Freq_Hz_mean,${QUEST.meanFreq().toFixed(4)}\n`;
  csv += `Freq_Hz_MAP,${QUEST.mapFreq().toFixed(4)}\n`;
  csv += `Tau_ms_mean,${QUEST.meanTau().toFixed(1)}\n`;
  csv += `Amp_contrast_pct,${QUEST.meanAmp().toFixed(2)}\n`;
  csv += `Base_threshold_pct,${QUEST.meanBase().toFixed(2)}\n`;
  csv += `Sigma_fixed,${QUEST.SIGMA_C}\n`;
  csv += `Trough1_soa_ms,${tr[0].soa_ms}\n`;
  csv += `Trough1_threshold_pct,${tr[0].threshold_pct}\n`;
  csv += `Trough2_soa_ms,${tr[1].soa_ms}\n`;
  csv += `Trough2_threshold_pct,${tr[1].threshold_pct}\n`;
  csv += `Trough3_soa_ms,${tr[2].soa_ms}\n`;
  csv += `Trough3_threshold_pct,${tr[2].threshold_pct}\n`;
  csv += `Confidence_pct,${(QUEST.confidence()*100).toFixed(2)}\n`;
  csv += `Valid_trials,${trials.filter(t=>t.valid).length}\n`;
  csv += `Discarded_trials,${trials.filter(t=>t.valid===false).length}\n`;
  const t1RTMean = t1RTs.length ? Math.round(t1RTs.reduce((a,b)=>a+b,0)/t1RTs.length) : '';
  csv += `Mean_T1_RT_ms,${t1RTMean}\n`;
  csv += `Median_T1_RT_ms,${t1RTs.length ? Math.round(medianT1RT) : ''}\n`;

  const blob=new Blob([csv],{type:'text/csv'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download=`theta_v2_${Date.now()}.csv`; a.click();
  URL.revokeObjectURL(url);
  toast('CSV exported');
}

// ════════════════════════════════════════════════════════════════════
//  STORAGE
// ════════════════════════════════════════════════════════════════════
function saveResult(hz, mapHz, trough1Ms, trough2Ms, ampVal, baseC, thr1, thr2, confPct) {
  const h = JSON.parse(localStorage.getItem('theta_history')||'[]');
  h.unshift({
    hz: parseFloat(hz).toFixed(2), mapHz: parseFloat(mapHz).toFixed(2),
    trough1Ms: Math.round(trough1Ms), trough2Ms: Math.round(trough2Ms),
    amp: parseFloat(ampVal).toFixed(1),
    baseC, thr1, thr2, confPct,
    trials: trials.filter(t=>t.valid).length,
    paradigm: 'v3.0',
    date: new Date().toLocaleDateString(),
    time: new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})
  });
  if(h.length>30) h.splice(30);
  localStorage.setItem('theta_history', JSON.stringify(h));
}

function renderHistory() {
  const list = document.getElementById('history-list');
  const h    = JSON.parse(localStorage.getItem('theta_history')||'[]');
  if (!h.length) {
    list.innerHTML = '<div style="color:var(--muted);font-size:12px;text-align:center;padding:32px;">No sessions yet.</div>';
    return;
  }
  list.innerHTML = h.map(s => `
    <div class="history-entry">
      <div>
        <div class="history-hz">${s.hz} Hz${s.paradigm?' <span style="font-size:9px;color:var(--muted)">'+s.paradigm+'</span>':''}</div>
        <div class="history-conf">T1: ${s.thr1??'—'}%@${s.trough1Ms??'—'}ms · T2: ${s.thr2??'—'}%@${s.trough2Ms??'—'}ms · A=${s.amp??'—'}% · Conf ${s.confPct}%</div>
      </div>
      <div class="history-meta">${s.date}<br>${s.time}<br>${s.trials} trials</div>
    </div>`).join('');
}

function clearHistory() {
  if (confirm('Clear all session history?')) {
    localStorage.removeItem('theta_history'); renderHistory();
  }
}

// ── Tap overlay event binding ─────────────────────────────────────────
// Use touchstart for lowest latency on iOS; fall back to pointerdown.
// preventDefault() on touchstart kills the 300ms delay and ghost clicks.
(function() {
  function bindTap() {
    const el = document.getElementById('tap-overlay');
    if (!el) return;
    // touchstart: lowest latency on iOS, prevent ghost pointerdown
    el.addEventListener('touchstart', function(e) {
      e.preventDefault();
      handleTap();
    }, { passive: false });
    // pointerdown: covers mouse + non-touch pointer devices
    el.addEventListener('pointerdown', function(e) {
      // Skip if already handled by touchstart (touch devices fire both)
      if (e.pointerType === 'touch') return;
      handleTap();
    });
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindTap);
  } else {
    bindTap();
  }
})();

// ── Boot ──────────────────────────────────────────────────────────────
if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js').catch(()=>{});
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initSettings);
} else {
  initSettings();
}
</script>
</body>
</html>